% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/NLP.R
\name{KerasTrainEval}
\alias{KerasTrainEval}
\title{KerasTrainEval}
\usage{
KerasTrainEval(
  PriorOutput = NULL,
  inputs = NULL,
  outputs = NULL,
  Name = NULL,
  Data_YTrain = NULL,
  Data_FeaturesTrain = NULL,
  Data_YTest = NULL,
  Data_FeaturesTest = NULL,
  Compile_optimizer = "rmsprop",
  Compile_loss = "binary_crossentropy",
  Compile_metrics = c("acc", "AUC"),
  Fit_validation_split = 0,
  Fit_class_weight = NULL,
  Fit_sample_weight = NULL,
  Fit_batch_size = 32,
  Fit_epochs = 10,
  Fit_shuffle = TRUE,
  Fit_callbacks = NULL,
  Fit_view_metrics = getOption("keras.view_metrics", default = "auto"),
  Fit_initial_epoch = 0,
  Fit_steps_per_epoch = NULL,
  Fit_validation_steps = NULL,
  ConfMatThresh = 0.5
)
}
\arguments{
\item{PriorOutput}{Default NULL. E.g. Output from a previous RemixAutoML::Keras() call. Ignore if using Sequential Mode (API = FALSE)}

\item{inputs}{Default NULL. E.g. c(Output$LayerList$text, Output$LayerList$features)}

\item{outputs}{Default NULL. E.g. Output$LayerList$outputtot}

\item{Name}{Default NULL. A name that is used to store and reference objects in the output list}

\item{Data_YTrain}{as.array(vector)}

\item{Data_FeaturesTrain}{input_train_text. Vector, matrix, or array of training data (or list if the model has multiple inputs). If all inputs in the model are named, you can also pass a list mapping input names to data. x can be NULL (default) if feeding from framework-native tensors (e.g. TensorFlow data tensors). You can also pass a tfdataset or a generator returning a list with (inputs, targets) or (inputs, targets, sample_weights).}

\item{Data_YTest}{as.array(vector). Vector, matrix, or array of target (label) data (or list if the model has multiple outputs). If all outputs in the model are named, you can also pass a list mapping output names to data. y can be NULL (default) if feeding from framework-native tensors (e.g. TensorFlow data tensors).}

\item{Data_FeaturesTest}{input_test_text}

\item{Fit_validation_split}{Default 0. Float between 0 and 1. Fraction of the training data to be used as validation data. The model will set apart this fraction of the training data, will not train on it, and will evaluate the loss and any model metrics on this data at the end of each epoch. The validation data is selected from the last samples in the x and y data provided, before shuffling.}

\item{Fit_class_weight}{E.g. list('0' = 1, '1' = nrow(YTrain) / sum(YTrain))}

\item{Fit_sample_weight}{= NULL}

\item{Fit_batch_size}{Default 32. Integer or NULL. Number of samples per gradient update. If unspecified, batch_size will default to 32.}

\item{Fit_epochs}{Default 10. Number of epochs to train the model. Note that in conjunction with initial_epoch, epochs is to be understood as "final epoch". The model is not trained for a number of iterations given by epochs, but merely until the epoch of index epochs is reached.}

\item{Fit_shuffle}{= TRUE, shuffle: Logical (whether to shuffle the training data before each epoch) or string (for "batch"). "batch" is a special option for dealing with the limitations of HDF5 data; it shuffles in batch-sized chunks. Has no effect when steps_per_epoch is not NULL.}

\item{Fit_callbacks}{Default NULL. List of callbacks to be called during training.}

\item{Fit_view_metrics}{Default getOption("keras.view_metrics", default = "auto"). View realtime plot of training metrics (by epoch). The default ("auto") will display the plot when running within RStudio, metrics were specified during model compile(), epochs > 1 and verbose > 0. Use the global keras.view_metrics option to establish a different default.}

\item{Fit_initial_epoch}{= 0,}

\item{Fit_steps_per_epoch}{= NULL,}

\item{Fit_validation_steps}{= NULL,}

\item{ConfMatThresh}{0.50}
}
\description{
Train model and generate evaluation metrics
}
\examples{
\dontrun{

Output <- RemixAutoML:::KerasTrainEval(
  PriorOutput = NULL, # Output
  inputs = NULL, # c(Output$LayerList$text, Output$LayerList$features),
  outputs = NULL, # Output$LayerList$outputtot,
  Name = NULL,
  Data_YTrain = y_train,
  Data_FeaturesTrain = T2S_Output[[1L]],
  Data_YTest = y_test,
  Data_FeaturesTest = T2S_Output[[2L]],
  Compile_optimizer = 'rmsprop',
  Compile_loss = 'binary_crossentropy',
  Compile_metrics = c("acc", "AUC"),
  Fit_validation_split = 0,
  Fit_class_weight = NULL,
  Fit_sample_weight = NULL,
  Fit_batch_size = 2000,
  Fit_epochs = 10,
  ConfMatThresh = 0.50)

# Step through function
PriorOutput = NULL # Output
inputs = c(Output$LayerList$text, Output$LayerList$features) # NULL
outputs = Output$LayerList$outputtot # NULL
Name = 'Model'
Data_YTrain = y_train
Data_FeaturesTrain = T2S_Output[[1L]]
Data_YTest = y_test
Data_FeaturesTest = T2S_Output[[2L]]
Compile_optimizer = 'rmsprop'
Compile_loss = 'binary_crossentropy'
Compile_metrics = c("acc", "AUC")
Fit_validation_split = 0
Fit_class_weight = NULL
Fit_sample_weight = NULL
Fit_batch_size = 2000
Fit_epochs = 10
Fit_shuffle = TRUE
Fit_callbacks = NULL
Fit_view_metrics = getOption("keras.view_metrics", default = "auto")
Fit_initial_epoch = 0
Fit_steps_per_epoch = NULL
Fit_validation_steps = NULL
ConfMatThresh = 0.50
}

}
\seealso{
Other DL: 
\code{\link{Keras_BinaryScoreEval}()},
\code{\link{Keras}()}
}
\author{
Adrian Antico
}
\concept{DL}
