% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/AutoLagRollStats.R
\name{AutoLagRollStats}
\alias{AutoLagRollStats}
\title{AutoLagRollStats}
\usage{
AutoLagRollStats(
  data,
  Targets = NULL,
  HierarchyGroups = NULL,
  IndependentGroups = NULL,
  DateColumn = NULL,
  TimeUnit = "day",
  TimeUnitAgg = "day",
  TimeGroups = "day",
  TimeBetween = NULL,
  RollOnLag1 = TRUE,
  Type = "Lag",
  SimpleImpute = TRUE,
  Lags = c(1:5),
  MA_RollWindows = c(2, 5, 10),
  SD_RollWindows = c(5, 10),
  Skew_RollWindows = c(5, 10),
  Kurt_RollWindows = c(5, 10),
  Quantile_RollWindows = c(10),
  Quantiles_Selected = c("q25", "q75"),
  Debug = FALSE
)
}
\arguments{
\item{data}{A data.table you want to run the function on}

\item{Targets}{A character vector of the column names for the reference column in which you will build your lags and rolling stats}

\item{HierarchyGroups}{A vector of categorical column names that you want to have generate all lags and rolling stats done for the individual columns and their full set of interactions.}

\item{IndependentGroups}{A vector of categorical column names that you want to have run independently of each other. This will mean that no interaction will be done.}

\item{DateColumn}{The column name of your date column used to sort events over time}

\item{TimeUnit}{List the time aggregation level for the time between events features, such as "hour", "day", "weeks", "months", "quarter", or "year"}

\item{TimeUnitAgg}{List the time aggregation of your data that you want to use as a base time unit for your features. E.g. "raw" or "day"}

\item{TimeGroups}{A vector of TimeUnits indicators to specify any time-aggregated GDL features you want to have returned. E.g. c("raw" (no aggregation is done),"hour", "day","week","month","quarter","year")}

\item{TimeBetween}{Specify a desired name for features created for time between events. Set to NULL if you don't want time between events features created.}

\item{RollOnLag1}{Set to FALSE to build rolling stats off of target columns directly or set to TRUE to build the rolling stats off of the lag-1 target}

\item{Type}{List either "Lag" if you want features built on historical values or "Lead" if you want features built on future values}

\item{SimpleImpute}{Set to TRUE for factor level imputation of "0" and numeric imputation of -1}

\item{Lags}{A numeric vector of the specific lags you want to have generated. You must include 1 if WindowingLag = 1.}

\item{MA_RollWindows}{A numeric vector of the specific rolling statistics window sizes you want to utilize in the calculations.}

\item{SD_RollWindows}{A numeric vector of Standard Deviation rolling statistics window sizes you want to utilize in the calculations.}

\item{Skew_RollWindows}{A numeric vector of Skewness rolling statistics window sizes you want to utilize in the calculations.}

\item{Kurt_RollWindows}{A numeric vector of Kurtosis rolling statistics window sizes you want to utilize in the calculations.}

\item{Quantile_RollWindows}{A numeric vector of Quantile rolling statistics window sizes you want to utilize in the calculations.}

\item{Quantiles_Selected}{Select from the following c("q5", "q10", "q15", "q20", "q25", "q30", "q35", "q40", "q45", "q50", "q55", "q60"," q65", "q70", "q75", "q80", "q85", "q90", "q95")}

\item{Debug}{Set to TRUE to get a print of which steps are running}
}
\value{
data.table of original data plus created lags, rolling stats, and time between event lags and rolling stats
}
\description{
AutoLagRollStats Builds lags and a large variety of rolling statistics with options to generate them for hierarchical categorical interactions.
}
\examples{
\dontrun{
# Create fake Panel Data----
Count <- 1L
for(Level in LETTERS) {
  datatemp <- RemixAutoML::FakeDataGenerator(
    Correlation = 0.75,
    N = 25000L,
    ID = 0L,
    ZIP = 0L,
    FactorCount = 0L,
    AddDate = TRUE,
    Classification = FALSE,
    MultiClass = FALSE)
  datatemp[, Factor1 := eval(Level)]
  if(Count == 1L) {
    data <- data.table::copy(datatemp)
  } else {
    data <- data.table::rbindlist(
      list(data, data.table::copy(datatemp)))
  }
  Count <- Count + 1L
}

# Add scoring records
data <- RemixAutoML::AutoLagRollStats(

  # Data
  data                 = data,
  DateColumn           = "DateTime",
  Targets              = "Adrian",
  HierarchyGroups      = NULL,
  IndependentGroups    = c("Factor1"),
  TimeUnitAgg          = "days",
  TimeGroups           = c("days", "weeks",
                           "months", "quarters"),
  TimeBetween          = NULL,
  TimeUnit             = "days",

  # Services
  RollOnLag1           = TRUE,
  Type                 = "Lag",
  SimpleImpute         = TRUE,

  # Calculated Columns
  Lags                 = list("days" = c(seq(1,5,1)),
                              "weeks" = c(seq(1,3,1)),
                              "months" = c(seq(1,2,1)),
                              "quarters" = c(seq(1,2,1))),
  MA_RollWindows       = list("days" = c(seq(1,5,1)),
                              "weeks" = c(seq(1,3,1)),
                              "months" = c(seq(1,2,1)),
                              "quarters" = c(seq(1,2,1))),
  SD_RollWindows       = NULL,
  Skew_RollWindows     = NULL,
  Kurt_RollWindows     = NULL,
  Quantile_RollWindows = NULL,
  Quantiles_Selected   = NULL,
  Debug                = FALSE)
}
}
\seealso{
Other Feature Engineering: 
\code{\link{AutoDataPartition}()},
\code{\link{AutoHierarchicalFourier}()},
\code{\link{AutoInteraction}()},
\code{\link{AutoLagRollStatsScoring}()},
\code{\link{AutoTransformationCreate}()},
\code{\link{AutoTransformationScore}()},
\code{\link{AutoWord2VecModeler}()},
\code{\link{ContinuousTimeDataGenerator}()},
\code{\link{CreateCalendarVariables}()},
\code{\link{CreateHolidayVariables}()},
\code{\link{DT_GDL_Feature_Engineering}()},
\code{\link{DifferenceDataReverse}()},
\code{\link{DifferenceData}()},
\code{\link{DummifyDT}()},
\code{\link{H2oAutoencoder}()},
\code{\link{ModelDataPrep}()},
\code{\link{Partial_DT_GDL_Feature_Engineering}()},
\code{\link{TimeSeriesFill}()}
}
\author{
Adrian Antico
}
\concept{Feature Engineering}
